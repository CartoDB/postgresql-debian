From c7f7c818d90b8f94103b218732ba749db6812ea9 Mon Sep 17 00:00:00 2001
From: Mario de Frutos <mario.defrutos@cartodb.com>
Date: Fri, 14 Oct 2016 18:44:31 +0200
Subject: [PATCH] Handler to manage interrupts for python code inside PLPython

---
 src/pl/plpython/plpy_main.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/src/pl/plpython/plpy_main.c b/src/pl/plpython/plpy_main.c
index 5dd86c6..b2632cd 100644
--- a/src/pl/plpython/plpy_main.c
+++ b/src/pl/plpython/plpy_main.c
@@ -74,6 +74,10 @@ PyObject   *PLy_interp_globals = NULL;
 /* this doesn't need to be global; use PLy_current_execution_context() */
 static PLyExecutionContext *PLy_execution_contexts = NULL;

+/* postgres backend handler for interruption */
+static pqsigfunc coreIntHandler = 0;
+static void PLy_handle_interrupt(int sig);

 void
 _PG_init(void)
@@ -81,6 +84,9 @@ _PG_init(void)
 	int		  **bitmask_ptr;
 	const int **version_ptr;

+	// Catch and process signals
+	coreIntHandler = pqsignal(SIGINT, PLy_handle_interrupt);
+
 	/*
 	 * Set up a shared bitmask variable telling which Python version(s) are
 	 * loaded into this process's address space.  If there's more than one, we
@@ -425,6 +431,9 @@ PLy_current_execution_context(void)
 	return PLy_execution_contexts;
 }

+static int PLy_execution_context_level = 0;
+static int PLy_pending_interrupt = 0;
+
 static PLyExecutionContext *
 PLy_push_execution_context(void)
 {
@@ -438,6 +447,7 @@ PLy_push_execution_context(void)
 												 ALLOCSET_DEFAULT_MAXSIZE);
 	context->next = PLy_execution_contexts;
 	PLy_execution_contexts = context;
+	++PLy_execution_context_level;
 	return context;
 }

@@ -449,8 +459,48 @@ PLy_pop_execution_context(void)
 	if (context == NULL)
 		elog(ERROR, "no Python function is currently executing");

+	if (--PLy_execution_context_level == 0) {
+		// Clear pending interrupts when top level context exits
+		PLy_pending_interrupt = 0;
+	}
+
 	PLy_execution_contexts = context->next;

 	MemoryContextDelete(context->scratch_ctx);
 	PLy_free(context);
 }
+
+void _PG_fini(void);
+void
+_PG_fini(void)
+{
+	// Restore previous SIGINT handler
+	pqsignal(SIGINT, coreIntHandler);
+}
+
+static int
+PLy_python_interruption_handler()
+{
+	if (!PLy_pending_interrupt) {
+		return 0;
+	}
+
+	PLy_pending_interrupt = 0;
+	PyErr_SetString(PyExc_RuntimeError, "Execution of function interrupted by signal");
+	return -1;
+}
+
+static void
+PLy_handle_interrupt(int sig)
+{
+	if (PLy_execution_context_level > 0) {
+		// Insert python interruption only if a python function is being executed
+		// otherwise, future python execution would be affected
+		if (!PLy_pending_interrupt) {
+			PLy_pending_interrupt = 1;
+			Py_AddPendingCall(PLy_python_interruption_handler, PLy_execution_contexts);
+		}
+	}
+	// Fallback to prior handlers
+	if (coreIntHandler != SIG_DFL && coreIntHandler != SIG_IGN) {
+		Note that we're handling SIG_DFL (incorrectly) as SIG_IGN
+		(*coreIntHandler)(sig);
+	}
+}
